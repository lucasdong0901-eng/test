<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; background:#0b0e14; color:#e8eefc;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      display:flex; align-items:center; justify-content:center; min-height:100vh;
    }
    .wrap { display:flex; gap:18px; align-items:flex-start; padding:16px; }
    canvas { background:#0f1420; border:1px solid #273047; border-radius:10px; }
    .panel {
      width:220px; display:flex; flex-direction:column; gap:12px;
      background:#0f1420; border:1px solid #273047; border-radius:12px; padding:12px;
    }
    .row { display:flex; justify-content:space-between; gap:10px; }
    .kbd { padding:2px 6px; border:1px solid #3a4766; border-radius:6px; background:#111a2a; }
    .muted { color:#aeb9d8; font-size:12px; line-height:1.4; }
    .title { font-weight:700; font-size:16px; }
    button {
      cursor:pointer; border:1px solid #3a4766; background:#111a2a; color:#e8eefc;
      padding:8px 10px; border-radius:10px; font-weight:600;
    }
    button:hover { filter:brightness(1.08); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="320" height="640"></canvas>

    <div class="panel">
      <div class="title">TETRIS</div>

      <div class="row"><span>점수</span><strong id="score">0</strong></div>
      <div class="row"><span>라인</span><strong id="lines">0</strong></div>
      <div class="row"><span>레벨</span><strong id="level">1</strong></div>

      <div class="muted">
        <div style="margin-bottom:6px;"><strong>조작</strong></div>
        <div><span class="kbd">←</span><span class="kbd">→</span> 이동</div>
        <div><span class="kbd">↓</span> 소프트 드랍</div>
        <div><span class="kbd">↑</span>/<span class="kbd">R</span> 회전</div>
        <div><span class="kbd">Space</span> 하드 드랍</div>
        <div><span class="kbd">P</span> 일시정지</div>
        <div><span class="kbd">Enter</span> 재시작</div>
      </div>

      <button id="restart">Enter로 재시작</button>
      <div class="muted" id="msg"></div>
    </div>
  </div>

<script>
(() => {
  const COLS = 10, ROWS = 20;
  const BLOCK = 32;
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const elScore = document.getElementById("score");
  const elLines = document.getElementById("lines");
  const elLevel = document.getElementById("level");
  const elMsg = document.getElementById("msg");
  document.getElementById("restart").onclick = () => reset();

  let board = makeMatrix(ROWS, COLS, 0);

  let score = 0, lines = 0, level = 1;
  let dropCounter = 0;
  let lastTime = 0;
  let paused = false;
  let gameOver = false;

  let shakePower = 0;
  let shakeTime = 0;

  function triggerShake(power, timeMs) {
    shakePower = Math.max(shakePower, power);
    shakeTime = Math.max(shakeTime, timeMs);
  }

  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [2,0,0],
      [2,2,2],
      [0,0,0],
    ],
    L: [
      [0,0,3],
      [3,3,3],
      [0,0,0],
    ],
    O: [
      [4,4],
      [4,4],
    ],
    S: [
      [0,5,5],
      [5,5,0],
      [0,0,0],
    ],
    T: [
      [0,6,0],
      [6,6,6],
      [0,0,0],
    ],
    Z: [
      [7,7,0],
      [0,7,7],
      [0,0,0],
    ],
  };

  const COLORS = [
    "#000000",
    "#53d6ff",
    "#3b7cff",
    "#ff9b3b",
    "#ffd54a",
    "#5dff7a",
    "#d46bff",
    "#ff4b6e",
    "#ffffff",
  ];

  let piece = null;

  function makeMatrix(r, c, v) {
    return Array.from({ length: r }, () => Array(c).fill(v));
  }

  function randomPiece() {
    const keys = Object.keys(SHAPES);
    const key = keys[(Math.random() * keys.length) | 0];
    return { key, mat: cloneMatrix(SHAPES[key]), x: 0, y: 0 };
  }

  function cloneMatrix(m) {
    return m.map(row => row.slice());
  }

  function spawn() {
    piece = randomPiece();
    piece.y = 0;
    piece.x = ((COLS / 2) | 0) - ((piece.mat[0].length / 2) | 0);

    if (collide(board, piece)) {
      gameOver = true;
      elMsg.textContent = "게임 오버! Enter로 재시작";
      triggerShake(10, 220);
    }
  }

  function collide(b, p) {
    const m = p.mat;
    for (let y = 0; y < m.length; y++) {
      for (let x = 0; x < m[y].length; x++) {
        if (m[y][x] !== 0) {
          const by = y + p.y;
          const bx = x + p.x;
          if (by < 0 || by >= ROWS || bx < 0 || bx >= COLS) return true;
          if (b[by][bx] !== 0) return true;
        }
      }
    }
    return false;
  }

  function merge(b, p) {
    p.mat.forEach((row, y) => {
      row.forEach((val, x) => {
        if (val !== 0) b[y + p.y][x + p.x] = val;
      });
    });
  }

  function clearLines() {
    let cleared = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (board[y][x] === 0) continue outer;
      }
      board.splice(y, 1);
      board.unshift(Array(COLS).fill(0));
      cleared++;
      y++;
    }

    if (cleared > 0) {
      const linePoints = [0, 100, 300, 500, 800];
      score += (linePoints[cleared] || (cleared * 200)) * level;
      lines += cleared;
      level = Math.max(1, ((lines / 10) | 0) + 1);
      triggerShake(4 + cleared * 2, 140);
    }
  }

  function rotate(mat, dir) {
    const N = mat.length;
    const res = makeMatrix(N, N, 0);
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) res[y][x] = mat[y][x];
    }
    for (let y = 0; y < N; y++) {
      for (let x = y + 1; x < N; x++) {
        const t = res[y][x];
        res[y][x] = res[x][y];
        res[x][y] = t;
      }
    }
    if (dir > 0) {
      for (let y = 0; y < N; y++) res[y].reverse();
    } else {
      res.reverse();
    }
    return res;
  }

  function tryRotate(dir) {
    const prev = piece.mat;
    piece.mat = rotate(piece.mat, dir);

    const offsets = [0, 1, -1, 2, -2];
    const px = piece.x;
    for (const off of offsets) {
      piece.x = px + off;
      if (!collide(board, piece)) return;
    }
    piece.mat = prev;
    piece.x = px;
  }

  function drop() {
    piece.y++;
    if (collide(board, piece)) {
      piece.y--;
      merge(board, piece);
      clearLines();
      spawn();
    }
    dropCounter = 0;
  }

  function hardDrop() {
    let d = 0;
    while (!collide(board, piece)) {
      piece.y++;
      d++;
      if (d > ROWS + 5) break;
    }
    piece.y--;
    merge(board, piece);
    triggerShake(3, 80);
    clearLines();
    spawn();
    dropCounter = 0;
  }

  function move(dx) {
    piece.x += dx;
    if (collide(board, piece)) piece.x -= dx;
  }

  function drawCell(x, y, v) {
    ctx.fillStyle = COLORS[v] || COLORS[8];
    ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.strokeRect(x * BLOCK + 0.5, y * BLOCK + 0.5, BLOCK - 1, BLOCK - 1);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let ox = 0, oy = 0;
    if (shakeTime > 0 && shakePower > 0) {
      ox = (Math.random() * 2 - 1) * shakePower;
      oy = (Math.random() * 2 - 1) * shakePower;
    }

    ctx.save();
    ctx.translate(ox, oy);

    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        const v = board[y][x];
        if (v !== 0) drawCell(x, y, v);
        else {
          ctx.strokeStyle = "rgba(39,48,71,0.35)";
          ctx.strokeRect(x * BLOCK + 0.5, y * BLOCK + 0.5, BLOCK - 1, BLOCK - 1);
        }
      }
    }

    if (piece && !gameOver) {
      const ghost = { x: piece.x, y: piece.y, mat: piece.mat };
      while (!collide(board, ghost)) ghost.y++;
      ghost.y--;

      ctx.globalAlpha = 0.25;
      ghost.mat.forEach((row, y) => row.forEach((val, x) => {
        if (val) drawCell(ghost.x + x, ghost.y + y, val);
      }));
      ctx.globalAlpha = 1;
    }

    if (piece) {
      piece.mat.forEach((row, y) => row.forEach((val, x) => {
        if (val) drawCell(piece.x + x, piece.y + y, val);
      }));
    }

    if (paused && !gameOver) overlayText("PAUSED");
    if (gameOver) overlayText("GAME OVER");

    ctx.restore();
  }

  function overlayText(txt) {
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0, canvas.height/2 - 48, canvas.width, 96);
    ctx.fillStyle = "#e8eefc";
    ctx.font = "700 34px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(txt, canvas.width/2, canvas.height/2 + 12);
  }

  function updateUI() {
    elScore.textContent = String(score);
    elLines.textContent = String(lines);
    elLevel.textContent = String(level);
  }

  function dropInterval() {
    const base = 800;
    return Math.max(80, base - (level - 1) * 70);
  }

  function update(time = 0) {
    const dt = time - lastTime;
    lastTime = time;

    if (!paused && !gameOver) {
      dropCounter += dt;
      if (dropCounter > dropInterval()) drop();
    }

    if (shakeTime > 0) {
      shakeTime -= dt;
      if (shakeTime <= 0) {
        shakeTime = 0;
        shakePower = 0;
      }
    }

    updateUI();
    draw();
    requestAnimationFrame(update);
  }

  window.addEventListener("keydown", (e) => {
    if (e.code === "KeyP") {
      paused = !paused;
      elMsg.textContent = paused ? "일시정지(P) 해제하려면 P" : "";
      return;
    }
    if (e.code === "Enter") { reset(); return; }
    if (paused || gameOver) return;

    if (e.code === "ArrowLeft") move(-1);
    else if (e.code === "ArrowRight") move(1);
    else if (e.code === "ArrowDown") drop();
    else if (e.code === "ArrowUp") tryRotate(1);
    else if (e.code === "KeyR") tryRotate(1);
    else if (e.code === "Space") hardDrop();
  });

  function reset() {
    board = makeMatrix(ROWS, COLS, 0);
    score = 0; lines = 0; level = 1;
    dropCounter = 0; lastTime = 0;
    paused = false; gameOver = false;
    shakePower = 0; shakeTime = 0;
    elMsg.textContent = "";
    spawn();
  }

  reset();
  update();
})();
</script>
</body>
</html>
